$date
	Mon Feb 13 23:36:54 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_serial_mul_8bit $end
$var wire 16 ! out [15:0] $end
$var reg 8 " a [7:0] $end
$var reg 8 # b [7:0] $end
$scope module mulp $end
$var wire 8 $ a [7:0] $end
$var wire 8 % b [7:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 ( out [15:0] $end
$var wire 16 ) bit_7_mux [15:0] $end
$var wire 16 * bit_6_mux [15:0] $end
$var wire 16 + bit_6_7_sum [15:0] $end
$var wire 16 , bit_5_mux [15:0] $end
$var wire 16 - bit_4_mux [15:0] $end
$var wire 16 . bit_4_5_sum [15:0] $end
$var wire 16 / bit_3_mux [15:0] $end
$var wire 16 0 bit_3_4_sum [15:0] $end
$var wire 16 1 bit_2_mux [15:0] $end
$var wire 16 2 bit_2_3_sum [15:0] $end
$var wire 16 3 bit_1_mux [15:0] $end
$var wire 16 4 bit_1_2_sum [15:0] $end
$var wire 16 5 bit_0_mux [15:0] $end
$var wire 16 6 bit_0_1_sum [15:0] $end
$scope module u0 $end
$var wire 16 7 a [15:0] $end
$var wire 16 8 b [15:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 9 sum [15:0] $end
$upscope $end
$scope module u1 $end
$var wire 16 : a [15:0] $end
$var wire 16 ; b [15:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 < sum [15:0] $end
$upscope $end
$scope module u2 $end
$var wire 16 = a [15:0] $end
$var wire 16 > b [15:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 ? sum [15:0] $end
$upscope $end
$scope module u3 $end
$var wire 16 @ a [15:0] $end
$var wire 16 A b [15:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 B sum [15:0] $end
$upscope $end
$scope module u4 $end
$var wire 16 C a [15:0] $end
$var wire 16 D b [15:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 E sum [15:0] $end
$upscope $end
$scope module u5 $end
$var wire 16 F a [15:0] $end
$var wire 16 G b [15:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 H sum [15:0] $end
$upscope $end
$scope module u6 $end
$var wire 16 I a [15:0] $end
$var wire 16 J b [15:0] $end
$var wire 1 & cin $end
$var wire 1 ' cout $end
$var wire 16 K sum [15:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx K
b0xxxxxxxx0000000 J
bx I
bx H
b0xxxxxxxx000000 G
bx F
bx E
b0xxxxxxxx00000 D
bx C
bx B
b0xxxxxxxx0000 A
bx @
bx ?
b0xxxxxxxx000 >
bx =
bx <
b0xxxxxxxx00 ;
bx :
bx 9
b0xxxxxxxx0 8
b0xxxxxxxx 7
bx 6
b0xxxxxxxx 5
bx 4
b0xxxxxxxx0 3
bx 2
b0xxxxxxxx00 1
bx 0
b0xxxxxxxx000 /
bx .
b0xxxxxxxx0000 -
b0xxxxxxxx00000 ,
bx +
b0xxxxxxxx000000 *
b0xxxxxxxx0000000 )
bx (
x'
0&
bx %
bx $
bx #
bx "
bx !
$end
#10
b1111111100000 !
b1111111100000 (
b1111111100000 K
0'
b111111100000 +
b111111100000 H
b111111100000 I
b11111100000 .
b11111100000 E
b11111100000 F
b1111100000 0
b1111100000 B
b1111100000 C
b111100000 2
b111100000 ?
b111100000 @
b11100000 4
b11100000 <
b11100000 =
b1100000 6
b1100000 9
b1100000 :
b100000 5
b100000 7
b1000000 3
b1000000 8
b10000000 1
b10000000 ;
b100000000 /
b100000000 >
b1000000000 -
b1000000000 A
b10000000000 ,
b10000000000 D
b100000000000 *
b100000000000 G
b1000000000000 )
b1000000000000 J
b100000 #
b100000 %
b11111111 "
b11111111 $
#30
b0 6
b0 9
b0 :
b100101000 4
b100101000 <
b100101000 =
b1101111000 2
b1101111000 ?
b1101111000 @
b1101111000 0
b1101111000 B
b1101111000 C
b1101111000 .
b1101111000 E
b1101111000 F
b1101111000 +
b1101111000 H
b1101111000 I
b1101111000 !
b1101111000 (
b1101111000 K
b0 5
b0 7
b0 3
b0 8
b100101000 1
b100101000 ;
b1001010000 /
b1001010000 >
b0 -
b0 A
b0 ,
b0 D
b0 *
b0 G
b0 )
b0 J
b1001010 #
b1001010 %
b1100 "
b1100 $
#50
b100100000 !
b100100000 (
b100100000 K
b100100000 +
b100100000 H
b100100000 I
b100100000 .
b100100000 E
b100100000 F
b100100000 0
b100100000 B
b100100000 C
b1100000 4
b1100000 <
b1100000 =
b100100000 2
b100100000 ?
b100100000 @
b1100000 1
b1100000 ;
b11000000 /
b11000000 >
b11000 #
b11000 %
#70
b100101101 !
b100101101 (
b100101101 K
b100101101 +
b100101101 H
b100101101 I
b1001101 0
b1001101 B
b1001101 C
b10101 6
b10101 9
b10101 :
b100101101 .
b100101101 E
b100101101 F
b10101 4
b10101 <
b10101 =
b1001101 2
b1001101 ?
b1001101 @
b111 5
b111 7
b1110 3
b1110 8
b11100000 ,
b11100000 D
b0 1
b0 ;
b111000 /
b111000 >
b111 #
b111 %
b101011 "
b101011 $
#1000
