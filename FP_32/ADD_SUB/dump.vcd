$date
	Mon Nov  6 14:13:42 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module tb_add_sub $end
$scope module fp32 $end
$var wire 32 ! add1 [31:0] $end
$var wire 32 " add2 [31:0] $end
$var wire 8 # add_one_in_exponent [7:0] $end
$var wire 1 $ command $end
$var wire 1 % current_add $end
$var wire 1 & current_sub $end
$var wire 24 ' final_f_concat [23:0] $end
$var wire 8 ( shift_nums [7:0] $end
$var wire 8 ) shift_before_add [7:0] $end
$var wire 1 * result_sign $end
$var wire 1 + result_shift_or_not $end
$var wire 32 , result [31:0] $end
$var wire 24 - man_b [23:0] $end
$var wire 24 . man_a [23:0] $end
$var wire 32 / final_result_e1e2eqzero [31:0] $end
$var wire 32 0 final_result_concat [31:0] $end
$var wire 32 1 final_result_add_or_sub [31:0] $end
$var wire 24 2 final_man_e1_eq_e2_eq_zero [23:0] $end
$var wire 48 3 final_f_add [47:0] $end
$var wire 8 4 final_exponent_e1e2eqzero [7:0] $end
$var wire 8 5 final_exponent [7:0] $end
$var wire 48 6 fianl_f_shift [47:0] $end
$var wire 47 7 extent_b [46:0] $end
$var wire 47 8 extent_a_shift [46:0] $end
$var wire 47 9 extent_a [46:0] $end
$var wire 8 : exponent_b [7:0] $end
$var wire 8 ; exponent_a [7:0] $end
$var wire 8 < e1_e2_0 [7:0] $end
$var wire 8 = e1_e2 [7:0] $end
$var wire 8 > current_exponent_tmp [7:0] $end
$var wire 1 ? add_or_sub $end
$var wire 1 @ add_or_not $end
$scope module adder $end
$var wire 47 A a [46:0] $end
$var wire 47 B b [46:0] $end
$var wire 48 C sum [47:0] $end
$upscope $end
$scope module adder_24 $end
$var wire 24 D sum [23:0] $end
$var wire 24 E b [23:0] $end
$var wire 24 F a [23:0] $end
$upscope $end
$scope module m_n $end
$var wire 48 G data [47:0] $end
$var wire 8 H shift_tmp [7:0] $end
$var wire 8 I shift [7:0] $end
$var wire 48 J outdata [47:0] $end
$upscope $end
$scope module norm $end
$var wire 1 % add $end
$var wire 32 K add1 [31:0] $end
$var wire 32 L add2 [31:0] $end
$var wire 1 & sub $end
$var wire 1 * result_sign $end
$var wire 2 M mode [1:0] $end
$var wire 24 N man_b_tmp [23:0] $end
$var wire 24 O man_b [23:0] $end
$var wire 24 P man_a_tmp [23:0] $end
$var wire 24 Q man_a [23:0] $end
$var wire 8 R exponent_b [7:0] $end
$var wire 8 S exponent_a [7:0] $end
$var wire 1 ? add_or_sub $end
$scope module pre_processing $end
$var wire 32 T a [31:0] $end
$var wire 1 % add $end
$var wire 32 U b [31:0] $end
$var wire 1 & sub $end
$var wire 1 * result_sign $end
$var wire 2 V mode [1:0] $end
$var wire 1 W abs_a_ht_b $end
$scope module mode_judge $end
$var wire 32 X a [31:0] $end
$var wire 1 % add $end
$var wire 32 Y b [31:0] $end
$var wire 1 & sub $end
$var wire 2 Z mode [1:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx Z
bx Y
bx X
xW
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
b0xxxxx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
x@
x?
bx >
bx =
bx <
bx ;
bx :
b0xxxxxxxxxxxxxxxxxxxxxxxx 9
bx 8
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
bx 1
bx 0
bx /
bx .
bx -
bx ,
x+
x*
bx )
bx (
bx '
x&
x%
x$
b1 #
bx "
bx !
$end
#10
b10011000 5
b11000 (
b11000 I
b100000000000000000000000100000000000000000000000 6
b100000000000000000000000100000000000000000000000 J
b0 H
b1000000100000000000000000000000 ,
b100000000000000000000000100000000000000000000000 3
b100000000000000000000000100000000000000000000000 C
b100000000000000000000000100000000000000000000000 G
b1001100000000000000000000000000 1
0*
1@
0?
b10000000 4
b1 )
b1000000000000000000000000 8
b1000000000000000000000000 A
b1 =
b1000000000000000000000000000000 /
b11111111111111111111111100000000000000000000000 7
b11111111111111111111111100000000000000000000000 B
1+
b10000000 <
b0 2
b0 D
b100000000000000000000000 -
b100000000000000000000000 E
b100000000000000000000000 O
b100000000000000000000000 9
b100000000000000000000000 '
b100000000000000000000000 .
b100000000000000000000000 F
b100000000000000000000000 Q
b10000000 >
b100000000000000000000000 N
b100000000000000000000000 P
b10000000 :
b10000000 R
b1000000100000000000000000000000 0
b10000001 ;
b10000001 S
b1 M
b1 V
b1 Z
1W
1&
0%
0$
b1000000000000000000000000000000 "
b1000000000000000000000000000000 L
b1000000000000000000000000000000 U
b1000000000000000000000000000000 Y
b1000000100000000000000000000000 !
b1000000100000000000000000000000 K
b1000000100000000000000000000000 T
b1000000100000000000000000000000 X
#20
b10000001 5
b1 (
b1 I
b10111 H
b1000000110000000000000000000000 1
b110000000000000000000000000000000000000000000000 6
b110000000000000000000000000000000000000000000000 J
b1100000000000000000000000 3
b1100000000000000000000000 C
b1100000000000000000000000 G
b100000000000000000000000 7
b100000000000000000000000 B
1?
b0 M
b0 V
b0 Z
0&
1%
1$
#30
b11000 (
b11000 I
b0 H
b100000000100101010111100 7
b100000000100101010111100 B
b1001000000000001110001101110110 /
b10010000 4
0@
b100000000100101010111100 -
b100000000100101010111100 E
b100000000100101010111100 O
b1110001101110110 2
b1110001101110110 D
b100000001001100010111010 9
b100000001001100010111010 '
b100000001001100010111010 .
b100000001001100010111010 F
b100000001001100010111010 Q
b1010100000000000000000000000000 1
b10101000 5
b10010000 >
b1010100000000000000000000000000 ,
b11110100 )
b100000000100101010111100 N
b100000001001100010111010 P
b10010000 :
b10010000 R
b1000010000000001001100010111010 0
b10000011 <
b100000000100101010111100 6
b100000000100101010111100 J
b100000000100101010111100 3
b100000000100101010111100 C
b100000000100101010111100 G
b0 8
b0 A
b11110100 =
b10000100 ;
b10000100 S
0W
b1001000000000000100101010111100 "
b1001000000000000100101010111100 L
b1001000000000000100101010111100 U
b1001000000000000100101010111100 Y
b1000010000000001001100010111010 !
b1000010000000001001100010111010 K
b1000010000000001001100010111010 T
b1000010000000001001100010111010 X
#40
b1001000001110101110001101110110 /
b1110101110001101110110 2
b1110101110001101110110 D
b101110101001100010111010 9
b101110101001100010111010 '
b101110101001100010111010 .
b101110101001100010111010 F
b101110101001100010111010 Q
b11110101 )
b101110101001100010111010 P
b1000010101110101001100010111010 0
b10000100 <
b11110101 =
b10000101 ;
b10000101 S
b1000010101110101001100010111010 !
b1000010101110101001100010111010 K
b1000010101110101001100010111010 T
b1000010101110101001100010111010 X
#50
b1011 (
b1011 I
b1101 H
b101110101001100010111010 7
b101110101001100010111010 B
b1000010101110101110001101110110 /
b10000101 4
b1001000000000000100101010111100 ,
b101110101001100010111010 -
b101110101001100010111010 E
b101110101001100010111010 O
b1110101110001101110110 2
b1110101110001101110110 D
b100000000100101010111100 9
b100000000100101010111100 '
b100000000100101010111100 .
b100000000100101010111100 F
b100000000100101010111100 Q
b10010000 5
b10000101 >
b1011 )
1@
b1001000000000000110001000001111 1
b101110101001100010111010 N
b100000000100101010111100 P
b10000101 :
b10000101 R
b1001000000000000100101010111100 0
b10001111 <
b100000000110001000001111000101110100000000000000 6
b100000000110001000001111000101110100000000000000 J
b10000000011000100000111100010111010 3
b10000000011000100000111100010111010 C
b10000000011000100000111100010111010 G
b10000000010010101011110000000000000 8
b10000000010010101011110000000000000 A
b1011 =
b10010000 ;
b10010000 S
1W
1&
0%
0$
b1001000000000000100101010111100 !
b1001000000000000100101010111100 K
b1001000000000000100101010111100 T
b1001000000000000100101010111100 X
b11000010101110101001100010111010 "
b11000010101110101001100010111010 L
b11000010101110101001100010111010 U
b11000010101110101001100010111010 Y
#2050
